\chapter{ALGORITHM FOR TREES}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\label{chap:dpp}

In this chapter, we propose a new algorithm for computing Betweennness Centrality specifically for trees. Consider a tree $T \equiv (V,E)$ such that $|V|=n$ and $|E|=n-1$.
To compute Betweenness Centrality for a tree, the Brandes' Algorithm by default takes $O(n^2)$ time.
We propose an algorithm with time complexity of $O(n)$.




%\begin{figure}[!htb]
%\centering

%\begin{minipage}{.5\textwidth}
%\centering
%\includegraphics[width=7cm]{images/Slide4.PNG}
%\caption{(a)}
%\label{fig:tree1.1}
%\end{minipage}%
%\begin{minipage}{.5\textwidth}
%\centering
%\includegraphics[width=7cm]{images/Slide5.PNG}
%\caption{(b)}
%\label{fig:tree1.2}
%\end{minipage}

%\end{figure}


\begin{figure}[h]
%\begin{center}

\subfigure[]{
        %\centering
        \includegraphics[scale=0.35]{images/Slide4.PNG}
        %\subcaption{Experimental setup}
        \label{fig:tree1.1}
}
\subfigure[]{
        %\centering
        \includegraphics[scale=0.4]{images/Slide5.PNG}
        %\caption{Image taken by two photon microsope}
        \label{fig:tree1.2}
}
\caption{Reachable vertices of $v$ }
\label{fig:tree1}
%\end{center}
\end{figure}


In Figure \ref{fig:tree1.1}, a vertex $v$ has four degree with edges as $e1$, $e2$, $e3$, $e4$ and $v1$, $v2$, $v3$, $v4$ corresponds to the number of vertices reachable through those edges respectively. We observe that any vertex from set $v1$ has a shortest path to any vertex in set $v2$ only through $v$. Same is applicable for $v1$ to $v3$, $v4$. Also other paths to be considered are from $v2$ to $v3$, $v4$ and $v3$ to $v4$.
So,

$bc[v] = v1*(v2+v3+v4) + v2*(v3*v4) + v3*v4$.
%\centering

In general we can say that for a vertex $v$ with a degree $d$, $bc[v]$ can be calculated using the equation \ref{eq4} where $v_{i}$ corresponds to number of vertices reachable from $i_{}^{th}$ edge.

\begin{equation} \label{eq4}
bc[v] = \sum_{i=1}^{d-1} v_{i}*(v_{i+1}+..+v_{n})
\end{equation}

Hence for calculating betweenness centrality we need to determine the number of vertices reachable through each edge of that vertex.

The proposed algorithm is divided into two pass.
\vspace{-0.5em}
\begin{enumerate}

  \item Computes the number of reachable vertices for each edge of a vertex.
  \item Computes Betweenness Centrality for a vertex using the values computed in the first pass.
\end{enumerate}
\begin{algorithm}

Select a root vertex $s$ arbitrarily\;
pass1($s$,-1)\;
pass2()\;
\caption{Betweenness Centrality of tree}
\label{treealgofull}
\end{algorithm}


\hspace{-1.5em}The proposed algorithm is as follows:
\\
A vertex $s$ is chosen arbitrarily as root. First pass and second pass are then applied on the tree considering $s$ as root.

\begin{figure}[htp]
\centering
\includegraphics[width=13cm]{images/exampletree.eps}
\caption{Example of Tree}
\label{fig:extree}
\end{figure}

\section{First Pass of Tree Algorithm}
\begin{algorithm}
%\KwResult{Write here the result }
dfs$(child, parent)$ \\
$sum \leftarrow 0$\;

\For{each neighbour vertex $v$ of $child$}{
\If{$v \neq parent$}{
$temp \leftarrow$ dfs($v,child$)\;
$sum \leftarrow sum + temp$\;
Push $temp$ to list[$child$]\;
}
}
return $sum + 1$\;
\caption{Pass1 of Tree Algorithm}
\label{treeealgo}
\end{algorithm}
Depth First Search(DFS) is performed on tree starting from $s$. Every vertex $v$ returns the number of vertices in its own subtree including the vertex $v$ to its parent $p$. The parent vertex adds the returned value from all of its children to its own list.
Vertex $v$ with a degree $d$ has a list of size $d$.
So at the end of first pass, the list of each vertex except source contains $d-1$ elements and source $s$ contains $d$ elements. The reason is that the source $s$ has no parent while every other vertex has exactly one parent. Hence, we need to add total number of vertices reachable through parent for all vertices except $s$.
For example, in Figure \ref{fig:extree} vertex '9' returns a value 3 to its parent '3' and vertex 3 adds to its list. Similarly at the end of pass 1, vertex $S$ has values 4, 3, 6 in its list whereas vertex '3' has values 3, 1, 1. 
\vspace{-1.0em}
\section{Second Pass of Tree Algorithm}
\vspace{-1.0em}
In the second pass of the algorithm, the number of vertices reachable through parent $s$ of a vertex $v$ are determined.
In Figure \ref{fig:tree1.2}, we know values of $v1$, $v2$ but to calculate the number of vertices reachable from parent $s$ that is through edge $e4$, we use the formula as
\\
no of vertices reachable through parent = total no of vertices - 1 - $(v1 + v2)$

In general we can say that,
\begin{equation} \label{eq5}
v_{d} = n - 1 + \sum_{i=1}^{d-1} list[v_{i}]
\end{equation}
where n is total number of vertices in graph, $v_{d}$ is number of reachable vertices through parent $s$.

For example, in Figure \ref{fig:extree}, for vertex '3' its list contains values 3, 1, 1. So to calculate the number of reachable vertices through its parent, applying formula we get (14 - 1 - (3+1+1)) = 8.

After calculating $v_{d}$, it is added to $list[v]$.
Thus the calculated value 8 is added to list of vertex '3'.
Since we know the total no. of vertices reachable from all edges of a vertex, we can calculate Betweenness Centrality using the equation \ref{eq4}.



\section{Time Complexity of the Algorithm}
First pass of the algorithm visits each node once and calculates the number of vertices reachable through its children.
Whereas in second pass of the algorithm, the number of vertices reachable through its parent are calculated using the formula for each and every vertex using the equation \ref{eq5} and the betweenness centrality is calculated using the equation \ref{eq4}. Hence its time complexity is $\theta$ ($n$) where $n$ is total number of vertices.


\section{Proof Of Correctness}

In a tree, since there is exactly one path between a pair of vertices, the path is also the shortest path between them. So the Betweenness Centrality value of a vertex $v$ becomes the total number of paths between any pair $s$ and $t$ passing through $v$, $s \neq t, v\neq t, s\neq v$ using Equation \ref{eqstart}. 
%Now, for an pair $<s$ , $t>$ whose shortest path passes through $v$, needs to be %reachable from different edges of $v$. 

\begin{lemma}
\label{lemma:first}
The shortest path from $s$ to $t$ through vertex $v$ should include two distinct edges incident on $v$ such that  $s \neq t, v\neq t, s\neq v$.
\end{lemma}

\begin{proof}
\begin{figure}
%\begin{center}

\subfigure[]{
        %\centering
        \includegraphics[scale=0.4]{images/Slide9.PNG}
        %\subcaption{Experimental setup}
        \label{fig:lemma1.1}
}
\subfigure[]{
        %\centering
        \includegraphics[scale=0.40]{images/Slide10.PNG}
        %\caption{Image taken by two photon microsope}
        \label{fig:lemma1.2}
}
\subfigure[]{
        %\centering
        \includegraphics[scale=0.40]{images/Slide11.PNG}
        %\caption{Image taken by two photon microsope}
        \label{fig:lemma1.3}
}
\caption{Cases for shortest path from $s$ to $t$ }
\label{fig:lemma1eg}
%\end{center}
\end{figure}

Figure \ref{fig:lemma1eg} shows the possible scenarios to be considered while computing the shortest path between $s$ and $t$ in the tree. In Figure \ref{fig:lemma1.1}, the shortest path between $s$ and $t$ won't pass through vertex $v$. Also in Figure \ref{fig:lemma1.2}, shortest path between $s$ and $t$ passes through $w$ and not $v$. In figure \ref{fig:lemma1.3}, shortest path between $s$ and $t$ does passes through vertex $v$. And this is the only case possible in which $s$ and $t$ are both incident through two distinct edges of $v$.

\end{proof}

\begin{lemma}
\label{lemma:second}
Consider any vertex $v \in V$, the number of shortest path between any pairs $< s, t >$ such that $s \in S, t \in T$, passing through $v$ are $|S| * |T|$ where $S$ and $T$ are set consisting of  vertices reachable through two distinct edges incident on $v$. 
\end{lemma}

\begin{proof}
By lemma \ref{lemma:first}, any shortest path between $s$ and $t$ passing through $v$ must be like figure \ref{fig:lemma1.3}.
Also, the set $S$ and $T$ consists of reachable vertices through two distinct edges incident on $v$, $S \cap T = \Phi$ as it is a tree.  Also total number of such $<s$ , $t>$ pairs possible are $|S| * |T|$. All these pairs will be unique pairs whose shortest path passes through $v$.
\end{proof}

Lemma \ref{lemma:second} holds for any vertex $v$ having $|S|$ and $|T|$ vertices through two distinct edges. Now, consider any vertex $v$ with $d$ edges.
We can choose any pair of edges from this $d$ edges in $\binom{d}{2}$ ways.
Hence for computing $bc[v]$, we consider all the edges incident on $v$, and choose any two edges and apply lemma \ref{lemma:second}, and add those values to $bc[v]$. This proves that our Equation \ref{eq4} is correct. The proposed algorithm calculates betweenness centrality for vertices using \ref{eq4}. Hence the proposed algorithm is correct.

% Let us assume that the betweenness centrality values calculated by our proposed algorithm is incorrect. Two cases arise that either our algorithm calculates more
% value of centrality or it calculates less than the actual value for a vertex $v$.



% \begin{enumerate}
% \item If our proposed algorithm has calculated more centrality value then for a pair $<s,t>$ whose shortest path does not contain $v$, some values are added to $bc[v]$. But according to Algorithm 2, it does not considers any pair $a,b$ which does not pass through $v$ and thus won't add any value to $bc[v]$.
% \item If our proposed algorithm has calculated less centrality value then for a pair $<s,t>$ whose shortest path contains $v$, some values are not added to $bc[v]$. 
% \\
% Algorithm 2 does not considers the vertices reachable from same edge. Since pair $<s,t>$ is not considered, then it should be reachable from $v$ through same edge and thus contradicts the information that $v$ lies on shortest path from $s$ to $t$
% \end{enumerate}

% Thus, both this cases are not possible which proves that our proposed algorithm is sound and complete.